/** metadata.c --- implementation of metadata.
 *
 * Copyright (C) 2013 Yang,Ying-chao
 *
 * Author: Yang,Ying-chao <yangyingchao@gmail.com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA 02110-1301, USA.
 */

#include "logutils.h"
#include "fileutils.h"
#include "metadata.h"
#include "mget_config.h"
#include "mget_utils.h"
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MIN_CHUNK_SIZE   (64*K)

extern log_level g_log_level;

bool metadata_create_from_file(const char *fn, metadata ** md,
                               fh_map ** fm_md)
{
    if (!fn || !md || !fm_md)
        return false;

    PDEBUG("Loading task from metadata...\n");
    bool     ret = false;
    fhandle *fh  = fhandle_create(fn, FHM_DEFAULT);
    fh_map  *fm  = ZALLOC1(fh_map);
    if (!fh)
        goto ret;

    if (!fm || !fhandle_mmap(fm, fh, 0, fh->size)) {
        fhandle_destroy(fh);
        goto ret;
    }

    *fm_md = fm;
    fm->fh = fh;

    metadata *pmd = (metadata *) fm->addr;
    *md = pmd;

    // Version checking for backward compatibility.
    if (VER_TO_MAJOR(pmd->hd.version) != VERSION_MAJOR) {
        mlog(ALWAYS, "Backward compatibility checking failed, "
             "current: %s, metadata created by: %u.%u.%u, "
             "please delete cached file(s), then try again...\n",
             VERSION_STRING, DIVIDE_VERSION(pmd->hd.version));

        goto ret;
    }

    mp *ptrs = ZALLOC1(mp);
    pmd->ptrs = ptrs;

    //TODO: version checks....
    ptrs->body = (data_chunk *) pmd->raw_data;
    ptrs->ht_buffer = (char *) (pmd->raw_data) +
                      sizeof(data_chunk) * pmd->hd.nr_effective;

    ptrs->ht = hash_table_create_from_buffer(pmd->ptrs->ht_buffer,
                                             pmd->hd.ebl);
    if (!ptrs->ht) {
        mlog(ALWAYS, "Failed to create hash table from buffer.\n");
        goto ret;
    }

    ptrs->url = (char *) hash_table_entry_get(pmd->ptrs->ht, K_URL);
    ptrs->fn = (char *) hash_table_entry_get(pmd->ptrs->ht, K_FN);
    ptrs->user = (char *) hash_table_entry_get(pmd->ptrs->ht, K_USR);
    ptrs->passwd =
            (char *) hash_table_entry_get(pmd->ptrs->ht, K_PASSWD);

    return true;

ret:
    if (fm) {
        fhandle_munmap(fm);
    }
    if (fh) {
        fhandle_destroy(fh);
    }

    return ret;
}

void metadata_display(metadata* md)
{
    if (!md || md->hd.nr_user == 1 || md->hd.nr_effective == 1)
        return;

    PDEBUG ("md: %p - %d - %d\n", md, md->hd.nr_user, md->hd.nr_effective);

    mlog(ALWAYS,
         "\nShowing metadata: %p, generated by version: %u.%u.%u\n",
         md, DIVIDE_VERSION(md->hd.version));
    if (!md) {
        mlog(ALWAYS, "Empty metadata!%s\n", "");
        return;
    }

    mlog(ALWAYS,
         "Size: %08" PRIXFAST64
         " (%.2f)M, Nc: %d, User: %p, Passwd: %p,\nurl: %s\n",
         md->hd.package_size, (float) md->hd.package_size / (1 * M),
         md->hd.nr_effective, md->ptrs->user,
         md->ptrs->passwd, md->ptrs->url);

    mlog(QUIET, "ptrs: raw_data: %p, chunk: %p, hash_buffer: %p\n",
         md->raw_data, md->ptrs->body, md->ptrs->ht_buffer);
    uint64 recv = 0;

    data_chunk *cp = (data_chunk *) md->raw_data;
    for (uint8 i = 0; i < md->hd.nr_effective; ++i, ++cp) {
        uint64 chunk_recv = cp->cur_pos - cp->start_pos;
        uint64 chunk_size = cp->end_pos - cp->start_pos;
        char *cs = strdup(stringify_size(chunk_size));
        char *es = strdup(stringify_size(cp->end_pos));

        recv += chunk_recv;
        mlog(ALWAYS,
             "Chunk: %d -- (%s), s: %08" PRIXFAST64 ", c: %08"
             PRIXFAST64 ", e: %08" PRIXFAST64 " (%s) -- %.02f%%\n",
             i, cs, cp->start_pos, cp->cur_pos,
             cp->end_pos, es, (float) (chunk_recv) / chunk_size * 100);
        free(cs);
        free(es);
    }
    mlog(ALWAYS, "%s finished...\n\n", stringify_size(recv));
}

bool chunk_split(uint64 size, int* num, uint64* chunk_size, data_chunk** dc)
{
    if (!size || !dc || !num) {
        return false;
    }

    if (*num <= 0) {
        *num = 1;
    }

    uint64 cs = size / *num;

    if (cs <= MIN_CHUNK_SIZE) {
        cs = MIN_CHUNK_SIZE;
    } else {
        cs = ((uint64) 1 << ((int) log2(cs / MIN_CHUNK_SIZE) + 1)) *
             MIN_CHUNK_SIZE;
    }

    *chunk_size = cs;
    uint32 total_size = *num * sizeof(data_chunk);

    *dc = (data_chunk *) malloc(total_size);
    memset(*dc, 0, total_size);
    data_chunk *dp = *dc;

    for (int i = 0; i < *num; ++i) {
        dp = *dc + i;
        dp->start_pos = i * cs;
        dp->cur_pos = i * cs;
        dp->end_pos = dp->cur_pos + cs;
        if (dp->end_pos >= size) {
            dp->end_pos = size;
            *num = i + 1;
            break;
        }
    }
    PDEBUG("results: chunk_size: %.02fM, nc: %d\n", (float) cs / M, *num);

    return true;
}

metadata *metadata_create_empty()
{
    return NULL;
}

void metadata_inspect(const char* path, mget_option* opts)
{
    metadata *md = NULL;
    fh_map *fm = NULL;
    if (opts)
        g_log_level = opts->ll;

    if (!metadata_create_from_file(path, &md, &fm)) {
        mlog(ALWAYS, "Failed to create metadata from file: %s\n", path);
        return;
    }

    metadata_display(md);
}

void metadata_destroy(metadata* md)
{
    if (!md || !md->ptrs)
        return;
    mp* p = md->ptrs;
    hash_table_destroy(p->ht);
    FIF(md->ptrs);
}

/*
 * Editor modelines
 *
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 4
 * indent-tabs-mode: nil
 * fill-column: 78
 * End:
 *
 * vim: set noet ts=4 sw=4:
 */
