/** metadata.c --- implementation of metadata.
 *
 * Copyright (C) 2013 Yang,Ying-chao
 *
 * Author: Yang,Ying-chao <yangyingchao@gmail.com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA 02110-1301, USA.
 */

#include "logutils.h"
#include "metadata.h"
#include <stdlib.h>
#include "fileutils.h"
#include <math.h>
#include <string.h>
#include "mget_utils.h"
#include <stdio.h>
#include "mget_config.h"

#define MIN_CHUNK_SIZE   (64*K)

#define SHOW_CHUNK(p)  PDEBUG ("%p, cur_pos: %08llX, end_pos: %08llX\n",p,p->cur_pos, p->end_pos)

extern log_level g_log_level;

bool metadata_create_from_file(const char *fn, metadata** md, fh_map** fm_md)
{
    PDEBUG ("enter with fn: %s\n", fn);

    bool     ret = false;
    fhandle *fh  = NULL;
    fh_map  *fm  = NULL;

    if (!fn || !md ||!fm_md)
        goto ret;

    if ((fh = fhandle_create(fn, FHM_DEFAULT)) &&
        (fm = fhandle_mmap(fh, 0, fh->size))) {

        *fm_md = fm;
        metadata* pmd = (metadata *) fm->addr;
        *md = pmd;

        // Version checking for backward compatibility.
        if (VER_TO_MAJOR(pmd->hd.version) != VERSION_MAJOR)
        {
            fprintf(stderr, "Backward compatibility checking failed, "
                    "current: %s, metadata created by: %u.%u.%u, "
                    "please delete cached file(s), then try again...\n",
                    VERSION_STRING, DIVIDE_VERSION(pmd->hd.version));

            goto ret;
        }

        mp* ptrs = ZALLOC1(mp);
        pmd->ptrs = ptrs;

        //TODO: version checks....
        ptrs->body = (data_chunk*) pmd->raw_data;
        ptrs->ht_buffer = (char*)(pmd->raw_data) +
                          sizeof(data_chunk) * pmd->hd.nr_effective;

        ptrs->ht = hash_table_create_from_buffer(pmd->ptrs->ht_buffer,
                                                 pmd->hd.ebl);
        if (!ptrs->ht)
        {
            fprintf(stderr, "Failed to create hash table from buffer.\n");
            goto ret;
        }

        ptrs->url = (char*)hash_table_entry_get(pmd->ptrs->ht, K_URL);
        ptrs->fn = (char*)hash_table_entry_get(pmd->ptrs->ht, K_FN);
        ptrs->user = (char*)hash_table_entry_get(pmd->ptrs->ht, K_USR);
        ptrs->passwd = (char*)hash_table_entry_get(pmd->ptrs->ht, K_PASSWD);

        return true;
    }

ret:
    if (fm) {
        fhandle_munmap(&fm);
    }
    if (fh) {
        fhandle_destroy(&fh);
    }

    return ret;
}

void metadata_display(metadata * md)
{
    fprintf(stderr,
            "\nShowing metadata: %p, generated by version: %u.%u.%u\n",
            md, DIVIDE_VERSION(md->hd.version));
    if (!md) {
        fprintf(stderr, "Empty metadata!%s\n", "");
        return;
    }

    fprintf(stderr, "size: %08llX (%.2f)M, nc: %d,url: %s, user: %p, passwd: %p\n",
            md->hd.package_size, (float) md->hd.package_size / (1 * M),
            md->hd.nr_effective, md->ptrs->url,
            md->ptrs->user, md->ptrs->passwd);

    fprintf(stderr, "ptrs: raw_data: %p, chunk: %p, hash_buffer: %p\n",
            md->raw_data, md->ptrs->body, md->ptrs->ht_buffer);
    uint64 recv = 0;

    data_chunk* cp = (data_chunk*)md->raw_data;
    for (uint8 i = 0; i < md->hd.nr_effective; ++i, ++cp) {
        uint64 chunk_recv = cp->cur_pos - cp->start_pos;
        uint64 chunk_size = cp->end_pos - cp->start_pos;
        char *cs = strdup(stringify_size(chunk_size));
        char *es = strdup(stringify_size(cp->end_pos));

        recv += chunk_recv;
        fprintf(stderr,
                "Chunk: %p -- (%s), start: %08llX, cur: %08llX, end: %08llX (%s) -- %.02f%%\n",
                cp, cs, cp->start_pos, cp->cur_pos,
                cp->end_pos, es, (float) (chunk_recv) / chunk_size * 100);
        free(cs);
        free(es);
    }
    fprintf(stderr, "%s finished...\n\n", stringify_size(recv));
}

bool chunk_split(uint64 start, uint64 size, int *num,
                 uint64* chunk_size, data_chunk ** dc)
{
    if (!size || !dc || !num) {
        return false;
    }

    if (*num <= 0) {
        *num = 1;
    }

    uint64 cs = size / *num;

    if (cs <= MIN_CHUNK_SIZE) {
        cs = MIN_CHUNK_SIZE;
    } else {
        cs = ((uint64) 1 << ((int) log2(cs / MIN_CHUNK_SIZE) + 1)) *
             MIN_CHUNK_SIZE;
    }

    *chunk_size = cs;
    uint32 total_size = *num * sizeof(data_chunk);

    *dc = (data_chunk *) malloc(total_size);
    memset(*dc, 0, total_size);
    data_chunk *dp = *dc;

    for (int i = 0; i < *num; ++i) {
        dp = *dc + i;
        dp->start_pos = i * cs;
        dp->cur_pos = i * cs;
        dp->end_pos = dp->cur_pos + cs;
        if (dp->end_pos >= size) {
            dp->end_pos = size;
            *num = i + 1;
            break;
        }
    }
    PDEBUG("results: chunk_size: %.02fM, nc: %d\n", (float) cs / M, *num);

    return true;
}

metadata* metadata_create_empty()
{
    return NULL;
}

void metadata_inspect(const char* path, mget_option* opts)
{
    metadata* md = NULL;
    fh_map*   fm = NULL;
    if (opts)
        g_log_level = opts->ll;

    if (!metadata_create_from_file(path, &md, &fm))
    {
        printf ("Failed to create metadata from file: %s\n", path);
        return;
    }

    metadata_display(md);
}

/*
 * Editor modelines
 *
 * Local Variables:
 * c-basic-offset: 4
 * tab-width: 4
 * indent-tabs-mode: nil
 * fill-column: 78
 * End:
 *
 * vim: set noet ts=4 sw=4:
 */
